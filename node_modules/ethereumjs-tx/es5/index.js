'use strict';

var txjs = module.exports;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ethUtil = require('ethereumjs-util');
var fees = require('ethereum-common/params.json');
var rlp = require('rlp');
const Buffer = require('safe-buffer').Buffer
var secp256k1 = require('secp256k1');
var BN = ethUtil.BN;

// secp256k1n/2
var N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);

/**
 * Creates a new transaction object.
 *
 * @example
 * var rawTx = {
 *   nonce: '00',
 *   gasPrice: '09184e72a000',
 *   gasLimit: '2710',
 *   to: '0000000000000000000000000000000000000000',
 *   value: '00',
 *   data: '7f7465737432000000000000000000000000000000000000000000000000000000600057',
 *   v: '1c',
 *   r: '5e1d3a76fbf824220eafc8c79ad578ad2b67d01b0c2425eb1f1347e8f50882ab',
 *   s: '5bd428537f05f9830e93792f90ea6a3e2d1ee84952dd96edbae9f658f831ab13'
 * };
 * var tx = new Transaction(rawTx);
 *
 * @class
 * @param {Buffer | Array | Object} data a transaction can be initiailized with either a buffer containing the RLP serialized transaction or an array of buffers relating to each of the tx Properties, listed in order below in the exmple.
 *
 * Or lastly an Object containing the Properties of the transaction like in the Usage example.
 *
 * For Object and Arrays each of the elements can either be a Buffer, a hex-prefixed (0x) String , Number, or an object with a toBuffer method such as Bignum
 *
 * @property {Buffer} raw The raw rlp encoded transaction
 * @param {Buffer} data.nonce nonce number
 * @param {Buffer} data.gasLimit transaction gas limit
 * @param {Buffer} data.gasPrice transaction gas price
 * @param {Buffer} data.to to the to address
 * @param {Buffer} data.value the amount of ether sent
 * @param {Buffer} data.data this will contain the data of the message or the init of a contract
 * @param {Buffer} data.v EC signature parameter
 * @param {Buffer} data.r EC signature parameter
 * @param {Buffer} data.s EC recovery ID
 * @param {Number} data.chainId EIP 155 chainId - mainnet: 1, ropsten: 3
 * */

var TXInput = function () {

  function TXInput(data) {
    _classCallCheck(this, TXInput);

    data = data || {};
    // Define Properties
    var fields = [{
      name: 'Txid',
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'Vout',
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'Signature',
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'PubKey',
      //length: 64,
      allowLess: true,
      default: new Buffer([])
    }];
    //var items = void 0;
    //items = inputs;

    /**
     * Returns the rlp encoding of the transaction
     * @method serialize
     * @return {Buffer}
     * @memberof Transaction
     * @name serialize
     */
    // attached serialize
    ethUtil.defineProperties(this, fields, data);
  }
  return TXInput;
}();


var TXOutput = function () {

  function TXOutput(data) {
    _classCallCheck(this, TXOutput);

    data = data || {};
    // Define Properties
    var fields = [{
      name: 'Value',
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'PubKeyHash',
      allowLess: true,
      default: new Buffer([])
    }];
    //var items = void 0;
    //items = inputs;

    /**
     * Returns the rlp encoding of the transaction
     * @method serialize
     * @return {Buffer}
     * @memberof Transaction
     * @name serialize
     */
    // attached serialize
    ethUtil.defineProperties(this, fields, data);
  }
  return TXOutput;
}();

var SwhTransaction = function () {

  function SwhTransaction(data) {
    _classCallCheck(this, SwhTransaction);

    data = data || {};
    // Define Properties
    var fields = [{
      name: 'ID',
      allowLess: true,
      default: new Buffer([])
    },{
      name: 'Vin',
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'Vout',
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'Timestamp',
      length: 64,
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'Data',
      allowZero: false,
      default: new Buffer([])
    }];
    //var items = void 0;
    //items = inputs;

    /**
     * Returns the rlp encoding of the transaction
     * @method serialize
     * @return {Buffer}
     * @memberof Transaction
     * @name serialize
     */
    // attached serialize
    ethUtil.defineProperties(this, fields, data);
    this.raw[0] = this.hash256(false,this.raw);
  }

  SwhTransaction.prototype.hash = function hash(includeSignature) {
    if (includeSignature === undefined) includeSignature = true;

    // EIP155 spec:
    // when computing the hash of a transaction for purposes of signing or recovering,
    // instead of hashing only the first six elements (ie. nonce, gasprice, startgas, to, value, data),
    // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0

    var items = void 0;
    if (includeSignature) {
      items = this.raw;
    } else {
      //if (this._chainId > 0) {
        var raw = this.raw.slice();
        items = this.raw;
        this.raw = raw;
      //} else {
      //  items = this.raw.slice(0, 4);
      //}
    }

    // create hash
    return ethUtil.rlpsha256(items);
  };

  SwhTransaction.prototype.hash256 = function hash(includeSignature,rawarray) {
    if (includeSignature === undefined) includeSignature = true;

    // EIP155 spec:
    // when computing the hash of a transaction for purposes of signing or recovering,
    // instead of hashing only the first six elements (ie. nonce, gasprice, startgas, to, value, data),
    // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0

    var items = void 0;
    if (includeSignature) {
      items = rawarray;
    } else {
      //if (this._chainId > 0) {
      var raw = rawarray.slice();
      items = raw;
      //} else {
      //  items = this.raw.slice(0, 4);
      //}
    }

    // create hash
    return ethUtil.rlpsha256(items);
  };

  function add0x (input) {
    if (typeof(input) !== 'string') {
      return input;
    }
    else if (input.length < 2 || input.slice(0,2) !== '0x') {
      return '0x' + input;
    }
    else {
      return input;
    }
  }
  SwhTransaction.prototype.sign = function sign(privateKey) {
    //TODO:
    // EIP155 spec:
    // when computing the hash of a transaction for purposes of signing or recovering,
    // instead of hashing only the first six elements (ie. nonce, gasprice, startgas, to, value, data),
    // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0
    /**************copy************/
    var rawTx = this.raw.slice();
    var dataIn = {};
    dataIn.ID = rawTx[0];
    dataIn.Vin = rawTx[1];
    dataIn.Vout = rawTx[2];
    dataIn.Timestamp = rawTx[3];
    dataIn.Data = rawTx[4];
    var txCopy = new SwhTransaction(dataIn);
    var txrawCopy = txCopy.raw.slice();
    txrawCopy[0] = ethUtil.toBuffer([]);

    var txvin = rlp.decode(txrawCopy[1]);
    var txvout = rlp.decode(txrawCopy[2]);
    var txins = []
    var txouts = []
    for(var i = 0;i < txvin.length;i++){
      var txinrawTx = ethUtil.stripHexPrefix(txvin[i]);
      var txin = new TXInput(new Buffer(txinrawTx , 'hex'))
      //var txin = new TXInput(txvin[i]);
      txin.Signature = ethUtil.toBuffer([]);
      txin.PubKey = ethUtil.toBuffer([]);
      txins[i] = txin.serialize();
    }
    txrawCopy[1] = rlp.encode(txins);

    var rawTx = ethUtil.stripHexPrefix(txrawCopy[4]);
    var txTxCopy = new Transaction(new Buffer(rawTx, 'hex'));
    txTxCopy.raw[6] = ethUtil.toBuffer([]);
    txrawCopy[4] = txTxCopy.serialize();
    txCopy.raw = txrawCopy;
    /*************copy*************/

    var txvinThis = rlp.decode(this.raw[1]);
    var txvin = rlp.decode(txCopy.raw[1]);
    var txvout = rlp.decode(txCopy.raw[2]);
    var txins = [];
    var txouts = [];
    var publicKey = ethUtil.privateToPublic(privateKey);

    for(var i = 0;i < txvin.length;i++){
      var txinrawTx = ethUtil.stripHexPrefix(txvin[i]);
      var txin = new TXInput(new Buffer(txinrawTx , 'hex'));
      var txinThis = new TXInput(new Buffer(txvinThis[i] , 'hex'));
      txin.Signature = ethUtil.toBuffer([]);
      txin.PubKey = txinThis.PubKey;

      txvin[i] = txin.serialize();
      txCopy.raw[1] = rlp.encode(txvin);

      var dataToSign = txCopy.hash(false);//ethUtil.rlpsha256(this.raw[0][i]);
      /*console.log("---datatosign rlp encode---")
      console.log(rlp.encode(txCopy.raw))
      console.log("---datatosign this.raw---")
      console.log(txCopy.raw)
      console.log("---datatosign---")
      console.log(dataToSign)*/
      //var sig = ethUtil.ecsignNoProtect(dataToSign, privateKey);
      var sig = {};
      var ret = secp256k1.sign(dataToSign, privateKey);
      sig.r = ret.signature.slice(0, 32);
      sig.s = ret.signature.slice(32, 64);
      sig.v = ret.recovery;
      var buf = Buffer.concat([ethUtil.setLengthLeft(sig.r, 32), ethUtil.setLengthLeft(sig.s, 32), ethUtil.toBuffer(sig.v)])

      txin.Signature = buf;
      txin.PubKey = ethUtil.toBuffer([]);

      txins[i] = txin;
    }

    //PubKey set to publicKey
    for(var i = 0;i < txins.length;i++){
      txins[i].PubKey = publicKey;
      txins[i] = txins[i].serialize();
      //txins[i] = txin.serialize().toString('hex');
    }

    for(var i = 0;i < txvout.length;i++){
      var txoutrawTx = ethUtil.stripHexPrefix(txvout[i]);
      var txout = new TXOutput(new Buffer(txoutrawTx , 'hex'));
      txouts[i] = txout.serialize();
    }
    this.raw[1] = rlp.encode(txins)
    this.raw[2] = rlp.encode(txouts)
    /*var msgHash = this.hash(false);
    var sig = ethUtil.ecsign(msgHash, privateKey);
    if (this._chainId > 0) {
      sig.v += this._chainId * 2 + 8;
    }
    Object.assign(this, sig);*/

    var rawTx = ethUtil.stripHexPrefix(this.raw[4]);
    var txCopy = new Transaction(new Buffer(rawTx, 'hex'));
    console.log("---Transaction---")
    console.log(txCopy.raw)
    txCopy.raw[6] = ethUtil.toBuffer([]);
    txCopy.sign(privateKey);
    this.raw[4] = txCopy.serialize();
  };

  return SwhTransaction;
}();
var Transaction = function () {
  function Transaction(data) {
    _classCallCheck(this, Transaction);

    data = data || {};
    // Define Properties
    var fields = [{
      name: 'nonce',
      length: 32,
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'gasPrice',
      length: 32,
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'gasLimit',
      alias: 'gas',
      length: 32,
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'to',
      allowZero: true,
      //length: 20,
      default: new Buffer([])
    }, {
      name: 'value',
      length: 32,
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 'data',
      alias: 'input',
      allowZero: true,
      default: new Buffer([])
    }, {
      name: 'v',
      allowZero: true,
      default: new Buffer([0x1c])
    }, {
      name: 'r',
      length: 32,
      allowZero: true,
      allowLess: true,
      default: new Buffer([])
    }, {
      name: 's',
      length: 32,
      allowZero: true,
      allowLess: true,
      default: new Buffer([])
    }];

    /**
     * Returns the rlp encoding of the transaction
     * @method serialize
     * @return {Buffer}
     * @memberof Transaction
     * @name serialize
     */
    // attached serialize
    ethUtil.defineProperties(this, fields, data);

    /**
     * @property {Buffer} from (read only) sender address of this transaction, mathematically derived from other parameters.
     * @name from
     * @memberof Transaction
     */
    Object.defineProperty(this, 'from', {
      enumerable: true,
      configurable: true,
      get: this.getSenderAddress.bind(this)
    });

    // calculate chainId from signature
    var sigV = ethUtil.bufferToInt(this.v);
    var chainId = Math.floor((sigV - 35) / 2);
    if (chainId < 0) chainId = 0;

    // set chainId
    this._chainId = chainId || data.chainId || 0;
    this._homestead = true;
  }

  /**
   * If the tx's `to` is to the creation address
   * @return {Boolean}
   */


  Transaction.prototype.toCreationAddress = function toCreationAddress() {
    return this.to.toString('hex') === '';
  };

  /**
   * Computes a sha3-256 hash of the serialized tx
   * @param {Boolean} [includeSignature=true] whether or not to inculde the signature
   * @return {Buffer}
   */


  Transaction.prototype.hash = function hash(includeSignature) {
    if (includeSignature === undefined) includeSignature = true;

    // EIP155 spec:
    // when computing the hash of a transaction for purposes of signing or recovering,
    // instead of hashing only the first six elements (ie. nonce, gasprice, startgas, to, value, data),
    // hash nine elements, with v replaced by CHAIN_ID, r = 0 and s = 0

    var items = void 0;
    if (includeSignature) {
      items = this.raw;
    } else {
      if (this._chainId > 0) {
        var raw = this.raw.slice();
        this.v = this._chainId;
        this.r = 0;
        this.s = 0;
        items = this.raw;
        this.raw = raw;
      } else {
        items = this.raw.slice(0, 6);
      }
    }

    console.log("---datatosign items---")
    console.log(items)
    console.log("---datatosign items rlp encode---")
    console.log(rlp.encode(items))
    // create hash
    return ethUtil.rlphash(items);
  };

  /**
   * returns the public key of the sender
   * @return {Buffer}
   */


  Transaction.prototype.getChainId = function getChainId() {
    return this._chainId;
  };

  /**
   * returns the sender's address
   * @return {Buffer}
   */


  Transaction.prototype.getSenderAddress = function getSenderAddress() {
    if (this._from) {
      return this._from;
    }
    var pubkey = this.getSenderPublicKey();
    this._from = ethUtil.publicToAddress(pubkey);
    return this._from;
  };

  /**
   * returns the sender's address
   * @return {Buffer}
   */


  Transaction.prototype.getSenderSwhAddress = function getSenderAddress() {
    if (this._from) {
      return this._from;
    }
    var pubkey = this.getSenderPublicKey();
    this._from = ethUtil.publicToSwhAddress(pubkey);
    return this._from;
  };

  /**
   * returns the public key of the sender
   * @return {Buffer}
   */


  Transaction.prototype.getSenderPublicKey = function getSenderPublicKey() {
    if (!this._senderPubKey || !this._senderPubKey.length) {
      if (!this.verifySignature()) throw new Error('Invalid Signature');
    }
    return this._senderPubKey;
  };

  /**
   * Determines if the signature is valid
   * @return {Boolean}
   */


  Transaction.prototype.verifySignature = function verifySignature() {
    var msgHash = this.hash(false);
    // All transaction signatures whose s-value is greater than secp256k1n/2 are considered invalid.
    if (this._homestead && new BN(this.s).cmp(N_DIV_2) === 1) {
      return false;
    }

    try {
      var v = ethUtil.bufferToInt(this.v);
      if (this._chainId > 0) {
        v -= this._chainId * 2 + 8;
      }
      this._senderPubKey = ethUtil.ecrecover(msgHash, v, this.r, this.s);
    } catch (e) {
      return false;
    }

    return !!this._senderPubKey;
  };

  /**
   * sign a transaction with a given a private key
   * @param {Buffer} privateKey
   */


  Transaction.prototype.sign = function sign(privateKey) {
    var msgHash = this.hash(false);
    console.log("---datatosign rlp encode---")
    console.log(rlp.encode(this.raw))
    console.log("---datatosign this.raw---")
    console.log(this.raw)
    console.log("---datatosign---")
    console.log(msgHash)
    var sig = ethUtil.ecsign(msgHash, privateKey);
    console.log("---datatosign sig---")
    console.log(sig.r)
    console.log(sig.s)
    console.log(sig.v)
    if (this._chainId > 0) {
      sig.v += this._chainId * 2 + 8;
    }
    Object.assign(this, sig);
  };



  /**
   * The amount of gas paid for the data in this tx
   * @return {BN}
   */


  Transaction.prototype.getDataFee = function getDataFee() {
    var data = this.raw[5];
    var cost = new BN(0);
    for (var i = 0; i < data.length; i++) {
      data[i] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
    }
    return cost;
  };

  /**
   * the minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
   * @return {BN}
   */


  Transaction.prototype.getBaseFee = function getBaseFee() {
    var fee = this.getDataFee().iaddn(fees.txGas.v);
    if (this._homestead && this.toCreationAddress()) {
      fee.iaddn(fees.txCreation.v);
    }
    return fee;
  };

  /**
   * the up front amount that an account must have for this transaction to be valid
   * @return {BN}
   */


  Transaction.prototype.getUpfrontCost = function getUpfrontCost() {
    return new BN(this.gasLimit).imul(new BN(this.gasPrice)).iadd(new BN(this.value));
  };

  /**
   * validates the signature and checks to see if it has enough gas
   * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean
   * @return {Boolean|String}
   */


  Transaction.prototype.validate = function validate(stringError) {
    var errors = [];
    if (!this.verifySignature()) {
      errors.push('Invalid Signature');
    }

    if (this.getBaseFee().cmp(new BN(this.gasLimit)) > 0) {
      errors.push(['gas limit is too low. Need at least ' + this.getBaseFee()]);
    }

    if (stringError === undefined || stringError === false) {
      return errors.length === 0;
    } else {
      return errors.join(' ');
    }
  };

  return Transaction;
}();

txjs.txinput = TXInput;
txjs.txoutput = TXOutput;
txjs.transaction = Transaction;
txjs.swhtransaction = SwhTransaction;
